local utils = require("main.game.dialogue.utils")
local get_visible_text = utils.get_visible_text
local LETTERS_PER_SECOND = utils.LETTERS_PER_SECOND

local SMALL_BALLOON_SPACE = 30 -- letters
local SMALL_BALLOON_MAX_LINES = 4
local BIG_BALLOON_SPACE = 49

local ORIENTATION = {UP=1, DOWN=-1, LEFT=-1, RIGHT=1}
local BIG_BALLOON = 1
local SMALL_BALLOON = 2
local NO_ARROW_BIG_BALLOON = 3
local NO_ARROW_SMALL_BALLOON = 4
local BALLOONS = {
	[BIG_BALLOON]={
		width=476,
		height=176,
		image="balloon1",
		offset=vmath.vector3(-50, 0, 0)
	},
	[SMALL_BALLOON]={
		width=296,
		height=128,
		image="balloon2",
		offset=vmath.vector3(0, 0, 0)
	},
	[NO_ARROW_BIG_BALLOON]={
		width=476,
		height=176,
		image="balloon3",
		offset=vmath.vector3(-50, 0, 0)
	},
	[NO_ARROW_SMALL_BALLOON]={
		width=296,
		height=128,
		image="balloon4",
		offset=vmath.vector3(0, 0, 0)
	}
}

-- When text is being displayed letter by letter and reaches the end of the line,
-- the word in the limit jumps to the next line. This function adds line breaks
-- before the words in the limit, so they pass to the next line, staying in their
-- positions and improving readability.
local function break_limit_words(text, balloon_space)
	local final_text = ""
	local line_letters = 0
	local word = ""
	local last_separator = nil
	for letter in text:gmatch(".") do
		local word_ended = false
		local word_fit = (line_letters + #word + 1) <= balloon_space
		if letter == " " or letter == "\n" then
			word_ended = true
		else
			word = word..letter
		end

		if word_ended then
			if last_separator == " " then
				local word_fit = (line_letters + #word + 1) <= balloon_space
				if word_fit then
					final_text = final_text.." "..word
					line_letters = line_letters + #word + 1
				else
					final_text = final_text.."\n"..word
					line_letters = #word
				end
			elseif last_separator == "\n" then
				final_text = final_text.."\n"..word
				line_letters = #word
			else
				final_text = final_text..word
				line_letters = line_letters + #word
			end

			last_separator = letter
			word = ""
		end
	end
	if last_separator then
		final_text = final_text..last_separator
	end
	final_text = final_text..word
	return final_text
end

local function get_balloon_to_use(text)
	local lines = 0
	for line in text:gmatch("[^\n]+") do
		lines = lines + math.ceil(line:len() / SMALL_BALLOON_SPACE)
	end

	if lines > SMALL_BALLOON_MAX_LINES then
		return BIG_BALLOON
	else
		return SMALL_BALLOON
	end
end

function init(self)
	self.label = msg.url("#label")
	self.big_label = msg.url("#big_label")
	self.current_label = self.label
	self.balloon_text = nil
	self.show_elapsed = 0
	self.last_message_id = 0
	self.current_balloon = SMALL_BALLOON
	self.current_character = nil

	msg.post(".", "disable")
end

function update(self, dt)
	if self.balloon_text then
		self.show_elapsed = self.show_elapsed + dt
		local visible_text = get_visible_text(self.balloon_text, self.show_elapsed)
		label.set_text(self.current_label, visible_text)
	end
end

local function hide_balloon(self)
	self.balloon_text = nil
	label.set_text(self.label, "")
	label.set_text(self.big_label, "")
	msg.post(".", "disable")
	self.current_character = nil
end

local function set_active_label(self, balloon)
	if balloon == BIG_BALLOON or balloon == NO_ARROW_BIG_BALLOON then
		msg.post(self.big_label, "enable")
		msg.post(self.label, "disable")
		self.current_label = self.big_label
	else
		msg.post(self.label, "enable")
		msg.post(self.big_label, "disable")
		self.current_label = self.label
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("hide") then
		hide_balloon(self)
	end

	if message_id == hash("character_moved") then
		sender.fragment = nil
		if self.current_character ~= sender then
			return
		end
		if self.current_balloon ~= SMALL_BALLOON and self.current_balloon ~= BIG_BALLOON then
			return
		end

		if self.current_balloon == SMALL_BALLOON then
			self.current_balloon = NO_ARROW_SMALL_BALLOON
		else
			self.current_balloon = NO_ARROW_BIG_BALLOON
		end
		local balloon = BALLOONS[self.current_balloon]
		msg.post("#sprite", "play_animation", {id = hash(balloon.image)})
	end
	
	if message_id == hash("show_text") then
		if not message.character then
			return
		end
		local text = break_limit_words(message.text, SMALL_BALLOON_SPACE) or ""
		
		self.last_message_id = self.last_message_id + 1
		local message_id = self.last_message_id

		local pos = go.get_position(message.character)
		local balloon_id = get_balloon_to_use(text)
		if balloon_id == BIG_BALLOON then
			text = break_limit_words(message.text, BIG_BALLOON_SPACE) or ""
		end
		
		local balloon = BALLOONS[balloon_id]
		self.current_balloon = balloon_id
		self.current_character = msg.url(message.character)
		
		local offset_x = balloon.width / 2 + balloon.offset.x
		local offset_y = balloon.height / 2 + balloon.offset.y
		
		local w, h = window.get_size()
		local h_orientation = ORIENTATION.RIGHT
		if pos.x + offset_x + (balloon.width / 2) >= w then
			h_orientation = ORIENTATION.LEFT
		end
		sprite.set_hflip("#sprite", h_orientation == ORIENTATION.LEFT)

		local v_orientation = ORIENTATION.UP
		if pos.y + offset_y + (balloon.height / 2) >= h then
			v_orientation = ORIENTATION.DOWN
		end
		sprite.set_vflip("#sprite", v_orientation == ORIENTATION.DOWN)
		
		pos.x = pos.x + (offset_x * h_orientation)
		pos.y = pos.y + (offset_y * v_orientation)
		pos.z = 1
		
		go.set_position(pos, ".")
		msg.post("#sprite", "play_animation", {id = hash(balloon.image)})

		self.balloon_text = text
		self.show_elapsed = 0

		set_active_label(self, balloon_id)
		label.set_text(self.current_label, "")
		msg.post(".", "enable")
	
		msg.post(message.character, message.event or "start_talking")	
		timer.delay(message.delay or ((text:len() / LETTERS_PER_SECOND) + 1), false, function(self, id)
			if message_id == self.last_message_id then
				hide_balloon(self)
			end	
			msg.post(message.character, "stop_talking")	
		end)

		if message.sound then
			local sound_url = "/dialogue"..message.sound
			msg.post(sound_url, "play_sound")

			local current_sound = self.last_sound
			timer.delay(0.5, false, function()	
				if current_sound and current_sound ~= self.last_sound then
					msg.post(current_sound, "stop_sound")
				end
			end)

			self.last_sound = sound_url
		end
	end
end
