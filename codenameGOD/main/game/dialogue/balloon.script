local inside_gameobject = require("main.inside_gameobject")
local utils = require("main.utils")

local BALLOON_SPACE_X = 476
local BALLOON_SPACE_Y = 180

local LETTERS_PER_SECOND = 20
local SMALL_BALLOON_SPACE = 31 -- letters
local SMALL_BALLOON_MAX_LINES = 3
local MIDDLE_BALLOON_SPACE = 39 -- letters
local MIDDLE_BALLOON_MAX_LINES = 4
local BIG_BALLOON_SPACE = 49

local ORIENTATION = {UP=1, DOWN=-1, LEFT=-1, RIGHT=1}
local BIG_BALLOON = 1
local MIDDLE_BALLOON = 2
local SMALL_BALLOON = 3
local NO_ARROW_BIG_BALLOON = 4
local NO_ARROW_MIDDLE_BALLOON = 5
local NO_ARROW_SMALL_BALLOON = 6
local BALLOONS = {
	[BIG_BALLOON]={
		width=476,
		height=176,
		image="balloon1",
		offset=vmath.vector3(-30, 60, 0)
	},
	[MIDDLE_BALLOON]={
		width=356,
		height=128,
		image="balloon2",
		offset=vmath.vector3(0, 30, 0)
	},
	[SMALL_BALLOON]={
		width=296,
		height=128,
		image="balloon3",
		offset=vmath.vector3(20, 15, 0)
	},
	[NO_ARROW_BIG_BALLOON]={
		width=476,
		height=176,
		image="balloon4",
		offset=vmath.vector3(-30, 60, 0)
	},
	[NO_ARROW_MIDDLE_BALLOON]={
		width=356,
		height=128,
		image="balloon5",
		offset=vmath.vector3(0, 30, 0)
	},
	[NO_ARROW_SMALL_BALLOON]={
		width=296,
		height=128,
		image="balloon6",
		offset=vmath.vector3(20, 15, 0)
	}
}

local get_visible_text = function(text, elapsed)
	local visible_count = math.min(text:len(), elapsed * LETTERS_PER_SECOND)
	return text:sub(0, visible_count)
end

-- When text is being displayed letter by letter and reaches the end of the line,
-- the word in the limit jumps to the next line. This function adds line breaks
-- before the words in the limit, so they pass to the next line, staying in their
-- positions and improving readability.
local function break_limit_words(text, balloon_space)
	local final_text = ""
	local line_letters = 0
	local word = ""
	local last_separator = "" -- No separator for the first word
	text = text.." "  -- This extra space will be ignored
	for letter in text:gmatch(".") do
		local word_ended = false
		local word_fit = (line_letters + #word + 1) <= balloon_space
		if letter == " " or letter == "\n" then
			word_ended = true
		else
			word = word..letter
		end

		if word_ended then
			local word_fit = (line_letters + #word + 1) <= balloon_space
			if last_separator == " " and not word_fit then
				last_separator = "\n"
			end

			final_text = final_text..last_separator..word
			if last_separator == " " then
				line_letters = line_letters + #word + 1
			else
				line_letters = #word
			end
			
			last_separator = letter
			word = ""
		end
	end
	return final_text
end

local function get_balloon_to_use(text)
	local small_lines = 0
	local middle_lines = 0
	for line in text:gmatch("[^\n]+") do
		small_lines = small_lines + math.ceil(line:len() / SMALL_BALLOON_SPACE)
		middle_lines = middle_lines + math.ceil(line:len() / MIDDLE_BALLOON_SPACE)
	end

	if small_lines <= SMALL_BALLOON_MAX_LINES then
		return SMALL_BALLOON
	end

	if middle_lines <= MIDDLE_BALLOON_MAX_LINES then
		return MIDDLE_BALLOON
	end

	return BIG_BALLOON
end

function init(self)
	msg.post(".","acquire_input_focus")

	self.label = msg.url("#label")
	self.label_inverted = msg.url("#label_inverted")
	self.middle_label = msg.url("#middle_label")
	self.middle_label_inverted = msg.url("#middle_label_inverted")
	self.big_label = msg.url("#big_label")
	self.skip = msg.url("#skip")
	self.skip_inverted = msg.url("#skip_inverted")
	self.middle_skip = msg.url("#middle_skip")
	self.middle_skip_inverted = msg.url("#middle_skip_inverted")	
	self.big_skip = msg.url("#big_skip")
	self.current_label = self.label
	self.current_skip = self.skip
	self.can_skip = false
	self.balloon_text = nil
	self.show_elapsed = 0
	self.last_message_id = 0
	self.current_balloon = SMALL_BALLOON
	self.current_character = nil
	self.balloon_visible = false
	self.skip_offset = {
		[self.skip] = vmath.vector3(34, 25, 0),
		[self.skip_inverted] = vmath.vector3(210, 20, 0),
		[self.middle_skip] = vmath.vector3(96, -2, 0),
		[self.middle_skip_inverted] = vmath.vector3(213, -2, 0),		
		[self.big_skip] = vmath.vector3(216, -28, 0)
	}

	msg.post(".", "disable")
end

function update(self, dt)
	if self.balloon_text then
		self.show_elapsed = utils.clamp(self.show_elapsed + dt, 0, self.balloon_text:len() / LETTERS_PER_SECOND)
		local visible_text = get_visible_text(self.balloon_text, self.show_elapsed)
		label.set_text(self.current_label, visible_text)
	end
end

local function hide_balloon(self)
	self.balloon_text = nil
	label.set_text(self.label, "")
	label.set_text(self.big_label, "")
	msg.post(".", "disable")
	self.current_character = nil
	self.balloon_visible = false
end

function get_balloon_label(self, balloon_id, h_orientation)
	if balloon_id == SMALL_BALLOON or balloon_id == NO_ARROW_SMALL_BALLOON then
		if h_orientation == ORIENTATION.RIGHT then
			return self.label
		else
			return self.label_inverted
		end
	elseif balloon_id == BIG_BALLOON or balloon_id == NO_ARROW_BIG_BALLOON then
		return self.big_label
	else
		if h_orientation == ORIENTATION.RIGHT then
			return self.middle_label
		else
			return self.middle_label_inverted
		end
	end
end

function get_balloon_skip(self, balloon_id, h_orientation)
	if balloon_id == SMALL_BALLOON or balloon_id == NO_ARROW_SMALL_BALLOON then
		if h_orientation == ORIENTATION.RIGHT then
			return self.skip
		else
			return self.skip_inverted
		end
	elseif balloon_id == BIG_BALLOON or balloon_id == NO_ARROW_BIG_BALLOON then
		return self.big_skip
	else
		if h_orientation == ORIENTATION.RIGHT then
			return self.middle_skip
		else
			return self.middle_skip_inverted
		end
	end
end

function disable_skips(self)
	msg.post(self.skip, "disable")
	msg.post(self.skip_inverted, "disable")
	msg.post(self.middle_skip, "disable")
	msg.post(self.middle_skip_inverted, "disable")	
	msg.post(self.big_skip, "disable")
end

function disable_labels(self)
	msg.post(self.label, "disable")
	msg.post(self.label_inverted, "disable")
	msg.post(self.middle_label, "disable")
	msg.post(self.middle_label_inverted, "disable")	
	msg.post(self.big_label, "disable")
end

local function set_active_elements(self, balloon_id, h_orientation)
	-- Set active label
	disable_labels(self)	
	self.current_label = get_balloon_label(self, balloon_id, h_orientation)
	msg.post(self.current_label, "enable")
	label.set_text(self.current_label, "")

	-- Set active skip button
	disable_skips(self)
	self.current_skip = get_balloon_skip(self, balloon_id, h_orientation)
	if self.can_skip then
		msg.post(self.current_skip, "enable")
	end
end

local function get_orientation(pos, balloon)
	local balloon_right = pos.x + balloon.width + balloon.offset.x 
	local balloon_top = pos.y + balloon.height + balloon.offset.y

	local w, h = window.get_size()
	
	-- The coordinates received internaly are still of the base resolution
	-- but the window size we received is the scaled size so we need to 
	-- adapt the other coordinates to match the scale
	local scale = vmath.vector3(w / WIDTH, h / HEIGHT, 1)
	
	local h_orientation = ORIENTATION.RIGHT
	if balloon_right * scale.x >= w then
		h_orientation = ORIENTATION.LEFT
	end

	local v_orientation = ORIENTATION.UP
	if balloon_top * scale.y >= h then
		v_orientation = ORIENTATION.DOWN
	end

	-- NOTE: For now we don't have balloons touching the top so we are ignoring the y flip
	return h_orientation, ORIENTATION.UP--v_orientation
end

local function show_balloon(self, character, raw_text, user_pos, no_arrow, allow_skip)
	local text = break_limit_words(raw_text, SMALL_BALLOON_SPACE) or ""

	local pos = user_pos or go.get_position(character)
	local balloon_id = get_balloon_to_use(text)
	if balloon_id == MIDDLE_BALLOON then 
		text = break_limit_words(raw_text, MIDDLE_BALLOON_SPACE) or ""
	elseif balloon_id == BIG_BALLOON then
		text = break_limit_words(raw_text, BIG_BALLOON_SPACE) or ""
	end

	if no_arrow then
		balloon_id = balloon_id + 3
	end
	local balloon = BALLOONS[balloon_id]
	self.current_balloon = balloon_id
	self.current_character = msg.url(character)

	local h_orientation, v_orientation = get_orientation(pos, balloon)
	sprite.set_hflip("#sprite", h_orientation == ORIENTATION.LEFT)
	sprite.set_vflip("#sprite", v_orientation == ORIENTATION.DOWN)

	pos.x = pos.x + (BALLOON_SPACE_X / 2 + balloon.offset.x) * h_orientation
	pos.y = pos.y + balloon.offset.y-- + (offset_y * v_orientation)
	pos.z = 0.9
	
	go.set_position(pos, ".")
	msg.post("#sprite", "play_animation", {id = hash(balloon.image)})

	self.balloon_text = text
	self.show_elapsed = 0

	msg.post(".", "enable")
	self.balloon_visible = true
	self.can_skip = allow_skip or false
	set_active_elements(self, balloon_id,  h_orientation)
	label.set_text(self.current_label, "")
end

local function balloon_play_sound(self, sound)
	local sound_url = "/balloon"..sound
	msg.post(sound_url, "play_sound")

	-- Stop old sound after 0.5s so it doesnt sound so weird when skipping dialog
	local current_sound = self.last_sound
	timer.delay(0.5, false, function()
		if current_sound and current_sound ~= self.last_sound then
			msg.post(current_sound, "stop_sound")
		end
	end)

	self.last_sound = sound_url
end

function on_message(self, message_id, message, sender)
	if message_id == hash("character_moved") then
		sender.fragment = nil
		if self.current_character ~= sender then
			return
		end
		if self.current_balloon ~= SMALL_BALLOON and self.current_balloon ~= BIG_BALLOON then
			return
		end

		if self.current_balloon == SMALL_BALLOON then
			self.current_balloon = NO_ARROW_SMALL_BALLOON
		else
			self.current_balloon = NO_ARROW_BIG_BALLOON
		end
		local balloon = BALLOONS[self.current_balloon]
		msg.post("#sprite", "play_animation", {id = hash(balloon.image)})
	end
	

	if message_id == hash("show_text") then
		if not message.character then
			return
		end
		show_balloon(self, message.character, message.text, message.pos, message.no_arrow, message.skip)

		self.last_message_id = self.last_message_id + 1
		local msg_id = self.last_message_id
		
		msg.post(message.character, message.event or "start_talking")	
		timer.delay(message.delay or ((self.balloon_text:len() / LETTERS_PER_SECOND) + 1), false, function(self, id)
			if msg_id == self.last_message_id then
				hide_balloon(self)
			end
			msg.post(message.character, "stop_talking")	
		end)

		if message.sound then
			balloon_play_sound(self, message.sound)
		end
	end

	-- Manual balloon control
	if message_id == hash("hide") then
		hide_balloon(self)
	end

	if message_id == hash("show") then
		show_balloon(self, message.character, "", message.pos, message.no_arrow, false)
	end

	if message_id == hash("add_text") then
		self.balloon_text = self.balloon_text..message.text
		if message.sound then
			balloon_play_sound(self, message.sound)
		end
	end	
end

local function skip_balloon(self)
	local total_duration = self.balloon_text:len() / LETTERS_PER_SECOND
	if self.show_elapsed < total_duration then
		self.show_elapsed = total_duration
	else
		event_manager:skip_event()
	end
end

function on_input(self, action_id, action)
	if self.balloon_visible and self.can_skip then
		if action_id == hash("click") and action.pressed then
			if inside_gameobject(self.current_skip, action.x, action.y, self.skip_offset[self.current_skip]) then
				skip_balloon(self)
			end
		end

		if action_id == hash("skip") and action.pressed then
			skip_balloon(self)
		end
	end
end